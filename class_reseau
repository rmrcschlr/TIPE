class reseau :
    
    def __init__(self, arrets, matrice) :
        self.liste_arrets = arrets
        self.liste_lignes = []
        self.matrice_segments = matrice
    # reseau -> list of string -> list of list of float -> reseau
    
    def ajouter_arret(self, nom) :
        self.liste_arrets.append(nom)
        for i in range(len(self.liste_arrets)) :
            self.matrice_segments[i].append(-1)
        self.matrice_segments.append((len(self.matrice_segments) * [-1]) + [0])
    # reseau -> string -> unit
    
    def changer_temps(self, indice_arret_init, indice_arret_final, temps) :
        self.matrice_segments[indice_arret_init][indice_arret_final] = temps
    # reseau -> int -> int -> float -> unit
    
    def ligne_correcte(self, ligne) :
        condition = True
        for arret in ligne[1] :
            condition = condition and (arret < len(self.liste_arrets))
        for terminus in ligne[2] :
            condition = condition and (terminus in ligne[1])
        return condition
    # reseau -> (string, list of int, list of int) -> bool
    
    def ajouter_ligne(self, nom, arrets, terminus) :
        liste_indices_arrets = []
        for arret in arrets :
            liste_indices_arrets.append(self.indice_arret(arret))
        liste_indices_terminus = []
        for arret in terminus :
            liste_indices_terminus.append(self.indice_arret(arret))
        ligne = [nom, liste_indices_arrets, liste_indices_terminus]
        if self.ligne_correcte(ligne) :
            self.liste_lignes.append(ligne)
        else :
            print("La ligne n'est pas correcte")
    # reseau -> string -> list of str -> list of str -> unit
    
    def ligne_arrets(self, indice) :
        return reseau.liste_lignes[indice][1]
    # reseau -> int -> int list
    
    def ligne_terminus(self, indice) :
        return reseau.liste_lignes[indice][2]
    # reseau -> int -> int list
    
    def indice_arret(self, nom) :
        indice = 0
        while indice < len(self.liste_arrets) and nom != self.liste_arrets[indice] :
            indice += 1
        if indice == len(self.liste_arrets) :
            return -1
        return indice
    # reseau -> string -> int
    
    def indice_ligne(self, nom) :
        indice = 0
        while indice < len(self.liste_lignes) and nom != self.liste_lignes[indice][0] :
            indice += 1
        if indice == len(self.liste_lignes) :
            return -1
        return indice
    # reseau -> string -> int
    
    def nom_arret(self, indice) :
        return self.liste_arrets[indice]
    # reseau -> int -> string
    
    def nom_ligne(self, indice) :
        return self.liste_lignes[indice]
    # reseau -> int -> string
    
    def afficher_ligne(self, indice) :
        result = []
        for i in range(len(self.ligne_arrets(indice))) :
             result.append(self.nom_arret(self.ligne_arrets(indice)[i]))
        return result
    # reseau -> string -> list of string
    
    def correspondance(self, indice_arret, indice_ligne):
        lignes = []
        ligne = self.liste_lignes[indice_ligne]
        for k, i in enumerate(self.liste_lignes) :
            if i != ligne :
                if indice_arret in self.liste_lignes[i] :
                    lignes.append(k)
        return lignes
    # reseau -> string -> int -> list of int
    
    def troncons(self, indice_ligne) :
        liste_troncons = []
        for indice_terminus in self.liste_terminus(indice_ligne) :
            troncon = []
            compteur = 0
            indice_arret = self.liste_arrets(indice_ligne)[compteur]
            while indice_arret != indice_terminus :
                troncon.append(indice_arret)
                compteur += 1
            while self.liste_arrets(indice_ligne)[indice_arret] != self.liste_terminus(indice_ligne)[(indice_terminus + 1) % len(self.liste_terminus(indice_ligne))] :
                indice_arret += 1
                troncon.append(self.liste_arrets(indice_ligne)[indice_arret])
            troncon.append(self.liste_arrets(indice_ligne)[indice_arret + 1])
            liste_troncons.append(troncon)
        return liste_troncons
    # reseau -> int -> list of list of string
    
    def duree(self, indice_ligne, arret_init, arret_final) :
        troncons_valides = []
        for indice_troncon, troncon in enumerate(self.troncons(indice_ligne)) :
            if (arret_init in self.troncons(indice_ligne)[indice_troncon]) and (arret_final in self.troncons(indice_ligne)[indice_troncon]) :
                troncons_valides.append(troncon)
        if troncons_valides == [] :
            print("Je ne peux pas calculer la durée pour l'instant")
            return -1
        durees = []
        for troncon in troncons_valides :
            indice = troncon.index(arret_init)
            duree = 0
            while troncon[indice] != arret_final and indice < len(troncon) - 1 :
                indice += 1
                duree += self.matrice_segments[self.liste_arrets.index(troncon[indice])][self.liste_arrets.index(troncon[indice + 1])]
            if (troncon[indice] == arret_final) or (troncon[indice + 1] == arret_final) :
                durees.append(duree)
        try :
            return min(durees)
        except ValueError :
            print("Je ne peux pas calculer la durée pour l'instant")
            return -1
    # reseau -> int -> string -> string -> float
