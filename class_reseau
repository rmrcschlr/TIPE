class Segment :
    
    def __init__(self, adresses, duree) :
        self.adresses = adresses
        self.duree = duree
        if adresses[0] == adresses[1] :
            self.duree = 0

class Arret :
    
    def __init__(self, adresse, nom) :
        self.adresse = adresse
        self.nom = nom

    # ou plutot faire un dictionnaire, a voir

class Ligne :
    
    def __init__(self, nom, portions, terminus) :
        self.nom = nom
        self.portions = portions
        self.terminus = terminus
    
    def verifier_cyclicite(self):
        cond = True
        for i in range(len(self.portions)) :
            if cond and self.portions[i-1].adresses[1] != self.portions[i].adresses[0] :
                cond = False
        return cond
    
    def liste_arrets(self) :
        result = []
        for i in range(len(self.portions)) :
            if not (self.portions[i].adresses[0] in result) :
                result.append(self.portions[i].adresses[0])
        return result
    
    def duree_totale(self) :
        somme = 0
        for i in range(len(self.portions)) :
            somme += self.portions[i].duree
        return somme
    
    def duree_trajet(self, debut, fin) :
        arret_actuel = debut
        temps = 0
        while arret_actuel != fin :
            compteur = 0
            while self.portions[compteur].adresses[0] != arret_actuel :
                compteur += 1
            temps += self.portions[compteur].duree
            arret_actuel = self.portions[compteur].adresses[1]
        return temps
            
class Reseau :
    
    def __init__(self, arrets, segments, lignes):
        self.arrets = []
        for i in range(len(arrets)):
            self.arrets.append(Arret(i,arrets[i]))
        self.segments = segments
        self.lignes = []
        for i in range(len(lignes)) :
            ajoute_ligne(lignes[i])
    
    def tout_relier_homogene(self, d) :
        self.segments = []
        for i in range(len(self.arrets)) :
            for j in range(len(self.arrets)) :
                self.segments.append(segment([i, j], d))
    
    def verifier_compatibilite(self, l) :
        for i in l.portions :
            if not (i in self.segments) :
                return False
        return True
    
    def ajoute_ligne(self, l) :
        if self.verifier_compatibilite(l) and l.verifier_cyclicite() :
            self.lignes.append(l)
        else :
            print("la ligne \"" + l.nom + "\" n'est pas compatible avec ce rÃ©seau")
    
    def liste_terminus(self) :
        result = []
        for i in range(len(self.lignes)) :
            result.append(self.lignes[i].terminus)
        return(result)
    
    def correspondances(self, l, a) :
        result = []
        for i in range(len(self.lignes)) :
            if self.lignes[i] != l :
                for j in range(len(self.lignes[i].liste_arrets())) :
                    if self.lignes[i].liste_arrets()[j] == a.adresse :
                        result.append(self.lignes[i])
        return result

class Frequences :
    
    def __init__(self, reseau) :
        self.liste
        for i in range(len(reseau.lignes)) :
            liste.append([])
    
    def trie_ligne(self, ligne) :
        self.liste[ligne].sort()
        i = 1
        while i < len(self.liste[ligne]) :
            if self.liste[i - 1] == self[i] :
                self.liste[ligne].pop(i)
                i -= 1
            i += 1
    
    def trie(self) :
        for i in range(len(self.liste)) :
            self.trie_ligne(i)
    
    def ajouter_tranche_horaire(self, ligne, debut, fin, cadence) :
        self.liste[ligne].append([debut, fin, cadence])
        self.trie_ligne(ligne)
    
    def tranches_ligne(self, ligne) :
        return self.liste[ligne]
    
    def normalise(self) :
        self.trie()
        for i in range(len(self.liste)) :
            for j in range(len(tranches_ligne(i)) - 1) :
                if self.liste[i][j][1] > self.liste[i][j + 1][0] :
                    moyenne = (self.liste[i][j][1] + self.liste[i][j + 1][0]) // 2
                    self.liste[i][j][1], self.liste[i][j + 1][0] = moyenne, moyenne
    
    def liste_departs(self, ligne) :
        # a voir si on fait ca dans cette classe ou la future classe variable (du futur programme programmation par contraintes maison)
