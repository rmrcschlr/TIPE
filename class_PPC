def inclus(liste1, liste2) :
    if liste1 == [] :
        return False
    result = True
    loop1 = 0
    while result and loop1 < len(liste1) :
        result = liste1[loop1] in liste2
        loop1 += 1
    return result

class CSP :
    
    def __init__(self, noms = [], domaine = []) :
        self.liste = []
        self.ajoute_variables(noms, domaine)
        self.contraintes = []
    # CSP -> string list -> int list -> CSP
    
    def noms(self) :
        result = []
        for i in range(len(self.liste)) :
            result.append(self.liste[i][1])
        return result
    # CSP -> string
    
    def ajoute_variable(self, nom, domaine) :
        if nom in self.noms() :
            print("la variable existe déjà")
        else :
            self.liste.append([0, nom, domaine]) # le O est l'arite de la variable
    # CSP -> string -> int list -> unit
    
    def ajoute_variables(self, noms, domaine) :
        if type(noms) is not list :
            self.ajoute_variable(noms, domaine)
        else :
            for i in range(len(noms)) :
                self.ajoute_variable(noms[i], domaine)
    # CSP -> string list -> int list -> unit
    
    def ajoute_contrainte(self, contrainte, variables) :
        for i in range(len(variables)) :
            if not(variables[i] in self.noms()) :
                return "la variable \"" + variables[i] + "\" n'existe pas"
        self.contraintes.append([contrainte, variables])
    # CSP -> fun( ints -> bool )-> string list
    
    def contraintes_sur_variable(self, variable) :
        result = []
        for i in range(len(self.contraintes)) :
            if variable in self.contraintes[i][1] :
                result.append(i)
        return result
    # CSP -> string -> int list
    
    def arite(self, variable) :
        return len(self.contraintes_sur_variable(variable))
    # CSP -> string -> int
    
    def trie_variables_statique(self) :
        for i in range(len(self.liste)) :
            self.liste[i][0] = self.arite(self.liste[i][1])
        self.liste.sort()
        self.liste.reverse()
    # CSP -> unit
    
def affectation_consistante(csp, affectation) :
    condition = True
    i = 0
    while condition and i < len(csp.contraintes) :
        if inclus(csp.contraintes[i][1], list(affectation.keys())) :
            valeurs = []
            for j in range(len(csp.contraintes[i][1])) :
                valeurs.append(affectation[csp.contraintes[i][1][j]])
            condition = condition and csp.contraintes[i][0](*valeurs)
        i += 1
    return condition
# CSP -> int dict -> bool

def anticipation(csp, affectation) :
    print(affectation)
    condition = True
    i = 0
    while condition and i < len(csp.liste) :
        condition = csp.noms()[i] in affectation
        i += 1
    if condition :
        return (True, affectation)
    i = len(affectation)
    variable_i = csp.liste[i]
    for valeur_i in variable_i[2] :
        liste_domaines_temporaires = []
        j = i + 1
        condition_valeur_i = True
        while condition_valeur_i and j < len(csp.liste) :
            variable_j = csp.liste[j]
            liste_domaines_temporaires.append([])
            for valeur_j in variable_j[2] :
                affectation_temporaire = affectation.copy()
                affectation_temporaire[variable_i[1]] = valeur_i
                affectation_temporaire[variable_j[1]] = valeur_j
                if affectation_consistante(csp, affectation_temporaire) :
                    liste_domaines_temporaires[j - i - 1].append(valeur_j)
            if liste_domaines_temporaires[j - i - 1] == [] :
                condition_valeur_i = False
            j += 1
        if [] not in liste_domaines_temporaires :
            affectation[variable_i[1]] = valeur_i
            for j in range(len(liste_domaines_temporaires)) :
                csp.liste[j + i + 1][2] = liste_domaines_temporaires[j]
            if anticipation(csp, affectation)[0] :
                return (True, affectation)
    print('fin')
    return (False, affectation)
# CSP -> int dict -> (bool, int dict)

def solution_par_anticipation(csp) :
    csp.trie_variables_statique()
    affectation = {}
    return anticipation(csp, affectation)
# CSP -> (bool, int dict)
